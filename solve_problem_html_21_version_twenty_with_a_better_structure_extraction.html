<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Problem Solver — MathQuill + PyScript</title>

  <!-- External Libraries -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mathquill/0.10.1/mathquill.min.css">
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathquill/0.10.1/mathquill.min.js"></script>
  
  <!-- PyScript with fallback -->
  <link rel="stylesheet" href="https://pyscript.net/releases/2024.1.1/core.css" />
  <script>
    function loadPyScript() {
      const script = document.createElement('script');
      script.src = 'https://pyscript.net/releases/2024.1.1/core.js';
      script.type = 'module';
      script.onload = () => console.log('✅ PyScript loaded');
      script.onerror = () => {
        const fallback = document.createElement('script');
        fallback.src = 'https://cdn.jsdelivr.net/npm/@pyscript/core@latest/dist/core.js';
        fallback.type = 'module';
        fallback.onload = () => console.log('✅ PyScript loaded from fallback');
        document.head.appendChild(fallback);
      };
      document.head.appendChild(script);
    }
    loadPyScript();
  </script>

  <style>
/* Target the MathQuill editable container */
.mq-editable-field {
  /* Base “outer” border style */
  border: 2px solid #007bff !important;
  border-radius: 4px !important;
  position: relative; /* ensure outline etc. are properly placed */
}

/* Remove or override MathQuill’s focus styling */
.mq-editable-field.mq-focused,
.mq-math-mode .mq-editable-field.mq-focused {
  /* Keep your border color on focus */
  border: 2px solid #007bff !important;
  /* Remove or suppress box-shadow (or replace with your own) */
  box-shadow: none !important;
  /* If MathQuill sets border-color, override it */
  border-color: #007bff !important;
}

/* If you used “double-border” via outline + border trick */
.mq-editable-field {
  border: 2px solid #005cbf !important;           /* inner border */
  outline: 3px solid #99c0ff !important;           /* outer border / highlight */
  outline-offset: 2px !important;
}

/* On focus, adjust the outer border if desired */
.mq-editable-field.mq-focused {
  outline: 3px solid #3399ff !important;
}

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          

    /* Minimal Input Buttons */
    .input-btn {
      padding: 10px;
      border-radius: 6px;
      border: 1px solid #cbd5e1;
      background: #ffffff;
      cursor: pointer;
      font-size: 16px;
      font-weight: 500;
      transition: all 0.15s ease;
      min-height: 44px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .input-btn:hover {
      background: #f1f5f9;
      border-color: #0b6efd;
      transform: translateY(-1px);
    }
    
    .input-btn:active {
      transform: translateY(0);
      background: #e2e8f0;
    }
    .input-btn.symbol {
      background: #fef3c7;
      border-color: #f59e0b;
      font-weight: 600;
      font-style: italic;
    }
    
    .input-btn.symbol:hover {
      background: #fde68a;
    }
    .input-btn.special {
      background: #fef3c7;
      border-color: #fbbf24;
    }
    
    .input-btn.special:hover {
      background: #fde68a;
    }
    
    .input-btn.operator {
      background: #dbeafe;
      border-color: #3b82f6;
      font-weight: 600;
    }
    
    .input-btn.operator:hover {
      background: #bfdbfe;
    }
    
    .input-btn.navigation {
      background: #e0e7ff;
      border-color: #818cf8;
      font-size: 14px;
    }
    
    .input-btn.navigation:hover {
      background: #c7d2fe;
    }
    
    .input-btn.delete {
      background: #fee2e2;
      border-color: #ef4444;
    }
    
    .input-btn.delete:hover {
      background: #fecaca;
    }
    /* Base Styles */
    * { box-sizing: border-box; }
    body { 
      font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial; 
      margin: 0; 
      padding: 0;
      background: #f3f6fb; 
      color: #0b1020; 
      overflow-x: hidden;
    }
    
    /* Layout */
    .app-container {
      display: flex;
      min-height: 100vh;
    }
    
    /* Sidebar */
    .sidebar {
      width: 320px;
      background: #fff;
      box-shadow: 4px 0 12px rgba(0,0,0,0.1);
      padding: 16px;
      overflow-y: auto;
      flex-shrink: 0;
      transition: transform 0.3s ease;
    }
    
    .sidebar-header {
      margin-bottom: 20px;
    }
    
    .nav-menu {
      margin-bottom: 20px;
    }
    
    .nav-item {
      display: flex;
      align-items: center;
      padding: 12px 16px;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
      margin-bottom: 4px;
      font-weight: 500;
    }
    
    .nav-item:hover {
      background: #f0f4ff;
    }
    
    .nav-item.active {
      background: #dbeafe;
      color: #1d4ed8;
    }
    
    .nav-icon {
      margin-right: 12px;
      font-size: 18px;
    }
    
    /* Main Content */
    .main-content {
      flex: 1;
      padding: 20px;
      max-width: 1200px;
      margin: 0 auto;
    }
    
    /* Pages */
    .page {
      display: none;
    }
    
    .page.active {
      display: block;
    }
    
    /* Components */
    .panel { 
      background: #fff; 
      padding: 16px; 
      border-radius: 10px; 
      box-shadow: 0 6px 20px rgba(11,20,40,0.06); 
      margin-bottom: 16px; 
    }
    
    .btn { 
      padding: 10px 16px; 
      border-radius: 8px; 
      border: none; 
      cursor: pointer; 
      background: #0b6efd; 
      color: #fff; 
      font-size: 15px; 
      font-weight: 500; 
      transition: all 0.2s ease;
      width: 100%;
      margin-bottom: 8px;
    }
    
    .btn:hover { 
      transform: translateY(-1px); 
      box-shadow: 0 4px 12px rgba(11,110,253,0.3); 
    }
    
    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }
    
    .btn.ghost { 
      background: transparent; 
      color: #0b6efd; 
      border: 1px solid #dbe9ff; 
    }
    
    .btn.ghost:hover { 
      background: rgba(11,110,253,0.05); 
    }
    
    label { 
      display: block; 
      font-weight: 600; 
      margin-bottom: 8px;
      font-size: 15px;
    }
    
    textarea {
      width: 100%;
      min-height: 120px;
      padding: 10px;
      border-radius: 8px;
      border: 1px solid #e6eef8;
      font-size: 14px;
      font-family: monospace;
      resize: vertical;
    }
    
    input[type="file"] {
      display: block;
      width: 100%;
      padding: 12px;
      border: 2px dashed #0b6efd;
      border-radius: 8px;
      margin-bottom: 12px;
      cursor: pointer;
      background: #f0f9ff;
      font-size: 14px;
      transition: all 0.2s ease;
    }
    
    input[type="file"]:hover {
      background: #dbeafe;
      border-color: #1d4ed8;
    }
    
    .math-input { 
      min-height: 44px; 
      border: 2px solid #e6eef8; 
      border-radius: 8px; 
      padding: 10px; 
      background: #fff;
      font-size: 18px;
    }
    
    /* Accordion */
    .accordion-problem { 
      border: 2px solid #e2e8f0; 
      border-radius: 12px; 
      margin-bottom: 16px; 
      background: #ffffff; 
      box-shadow: 0 4px 12px rgba(0,0,0,0.08); 
      overflow: hidden; 
    }
    
    .accordion-problem.open { 
      border-color: #3b82f6; 
    }
    
    .accordion-problem.finished { 
      border-color: #10b981; 
      background: #f0fdf4; 
    }
    
    .accordion-header { 
      padding: 16px; 
      font-weight: 700; 
      cursor: pointer; 
      display: flex; 
      justify-content: space-between; 
      align-items: center; 
      background: #f0f4ff; 
      transition: background 0.2s ease;
      font-size: 16px;
      min-height: 60px;
    }
    
    .accordion-header:hover { 
      background: #dbeafe; 
    }
    
    .accordion-body { 
      max-height: 0; 
      overflow: hidden; 
      transition: max-height 0.3s ease-in-out; 
      padding: 0 16px; 
    }
    
    .accordion-problem.open .accordion-body { 
      max-height: 10000px; 
      padding: 16px; 
    }
    
    .progress-summary { 
      font-size: 14px; 
      color: #6b7280; 
      font-weight: 600; 
    }
    
    /* Step styling */
    .step {
      padding: 16px;
      font-size: 16px;
    }
    
    .step-description {
      background: #f0fdf4;
      padding: 14px;
      border-radius: 8px;
      margin-bottom: 14px;
      font-size: 16px;
      line-height: 1.6;
    }
    
    .step-feedback {
      font-size: 15px;
      padding: 10px;
      border-radius: 6px;
      margin-top: 10px;
      font-weight: 600;
    }
    
    .attempts-history {
      margin-top: 12px;
      max-height: 400px;
      overflow-y: auto;
      background: #f8fafc;
      padding: 10px;
      border-radius: 8px;
      font-size: 14px;
    }
    
    /* Loading */
    #loadingOverlay { 
      position: fixed; 
      top: 0; 
      left: 0; 
      right: 0; 
      bottom: 0; 
      background: rgba(15,23,42,0.95); 
      z-index: 9999; 
      display: flex; 
      flex-direction: column; 
      align-items: center; 
      justify-content: center; 
      color: #fff; 
    }
    
    .spinner { 
      width: 60px; 
      height: 60px; 
      border: 4px solid rgba(59,130,246,0.3); 
      border-top-color: #3b82f6; 
      border-radius: 50%; 
      animation: spin 1s linear infinite; 
      margin-bottom: 20px; 
    }
    
    @keyframes spin { 
      to { transform: rotate(360deg); } 
    }
    
    /* Storage Indicator */
    .storage-indicator { 
      position: fixed; 
      bottom: 16px; 
      right: 16px; 
      padding: 10px 14px; 
      background: #10b981; 
      color: #fff; 
      border-radius: 8px; 
      font-size: 13px; 
      opacity: 0; 
      transition: opacity 0.3s; 
      pointer-events: none; 
      z-index: 1000;
      font-weight: 600;
    }
    
    .storage-indicator.show { 
      opacity: 1; 
    }
    
    /* Mobile Responsive */
    @media (max-width: 768px) {
      .app-container {
        flex-direction: column;
      }
      
      .sidebar {
        position: fixed;
        left: -320px;
        top: 0;
        width: 320px;
        height: 100vh;
        z-index: 1000;
        box-shadow: 4px 0 12px rgba(0,0,0,0.1);
      }
      
      .sidebar.open {
        left: 0;
      }
      
      .main-content {
        padding: 16px;
      }
      
      .menu-btn {
        position: fixed;
        top: 12px;
        left: 12px;
        z-index: 1001;
        width: 48px;
        height: 48px;
        background: #0b6efd;
        color: #fff;
        border: none;
        border-radius: 12px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 24px;
        box-shadow: 0 4px 12px rgba(11,110,253,0.4);
      }
      
      .sidebar-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.5);
        z-index: 999;
        display: none;
      }
      
      .sidebar-overlay.show {
        display: block;
      }
    }
    
    @media (min-width: 769px) {
      .menu-btn,
      .sidebar-overlay {
        display: none !important;
      }
    }
  </style>
</head>
<body>
  <!-- Loading Overlay -->
  <div id="loadingOverlay">
    <div class="spinner"></div>
    <div class="loading-text">Initializing Problem Solver...</div>
    <div id="loadingStatus">
      <div>⏳ Starting up...</div>
    </div>
  </div>

  <!-- Mobile Menu Button -->
  <button class="menu-btn" id="menuBtn">☰</button>
  
  <!-- Sidebar Overlay -->
  <div class="sidebar-overlay" id="sidebarOverlay"></div>
  
  <!-- Main App Container -->
  <div class="app-container">
    <!-- Sidebar -->
    <aside class="sidebar" id="sidebar">
      <div class="sidebar-header">
        <h3>🧮 Problem Solver</h3>
      </div>
      
      <!-- Problem Set Info -->
      <div id="problemSetInfo" class="panel" style="display:none;">
        <div style="font-size:16px; font-weight:700; margin-bottom:8px;">Problem Set</div>
        <div id="currentProblemSetDescription" style="font-size:14px; color:#64748b; margin-bottom:8px;">No problem set loaded</div>
        <div id="currentProblemSetUuid" style="font-family:monospace; font-size:12px; color:#0369a1; background:#f0f9ff; padding:8px; border-radius:6px;">No UUID</div>
      </div>
      
      <!-- Navigation -->
      <nav class="nav-menu">
        <div class="nav-item active" data-page="problems">
          <span class="nav-icon">🧮</span>
          <span>Problems</span>
        </div>
        <div class="nav-item" data-page="load">
          <span class="nav-icon">📂</span>
          <span>Load</span>
        </div>
        <div class="nav-item" data-page="export">
          <span class="nav-icon">📤</span>
          <span>Export</span>
        </div>
        <div class="nav-item" data-page="settings">
          <span class="nav-icon">⚙️</span>
          <span>Settings</span>
        </div>
      </nav>
    </aside>

    <!-- Main Content -->
    <main class="main-content">
      <!-- Problems Page -->
      <div id="problemsPage" class="page active">
        <div id="initialLoadPanel" class="panel">
          <h3>📂 Load Problem Set</h3>
          <p>No problems loaded. Use the sidebar to load a problem set.</p>
        </div>
        <div id="solveProblemsContainer"></div>
      </div>
      
      <!-- Load Page -->
      <div id="loadPage" class="page">
        <div class="panel">
          <h3>📂 Load Problem Set</h3>
          
          <label>📎 Upload File</label>
          <input type="file" id="uploadFile" accept=".txt,text/plain" />
          
          <div style="text-align:center;margin:12px 0;color:#94a3b8;">— OR —</div>
          
          <label>📋 Paste JSON</label>
          <textarea id="pasteJson" placeholder="Paste base64-compressed JSON"></textarea>
          <button id="loadJsonBtn" class="btn">📂 Load Problems</button>
          
          <hr style="margin:16px 0;border:none;border-top:1px solid #e5e7eb;">
          
          <button id="resetSolveBtn" class="btn ghost">♻️ Reset Current</button>
        </div>
      </div>
      
      <!-- Export Page -->
      <div id="exportPage" class="page">
        <div class="panel">
          <h3>📤 Export Progress</h3>
          <button id="exportProgressBtn" class="btn" style="background:#10b981;">📤 Export Progress</button>
          <button id="exportTelegramBtn" class="btn" style="background:#0088cc;">✈️ Export to Telegram</button>
        </div>
      </div>
      
      <!-- Settings Page -->
      <div id="settingsPage" class="page">
        <div class="panel">
          <h3>⚙️ Settings</h3>
          <button id="clearStorageBtn" class="btn ghost" style="background:#dc2626; color:#fff;">🗑️ Clear All Data</button>
        </div>
      </div>
    </main>
  </div>

  <!-- Storage Indicator -->
  <div id="storageIndicator" class="storage-indicator">💾 Saved</div>

  <!-- PyScript Configuration -->
  <py-config>
    packages = ["sympy", "lark", "brotli"]
  </py-config>

  <!-- Python Script -->
  <script type="py">
from pyscript import document, window
from pyodide.ffi import create_proxy
import json, html, re, base64, uuid

# Consolidated Math Parser
class MathParser:
    """Handles LaTeX parsing with improved grammar and structure extraction"""
    
    GRAMMAR = r"""
    start: matrix_ops
         | expr

    ?expr: sum

    ?sum: sum "+" product   -> add
        | sum "-" product   -> sub
        | product

    ?product: scalar matrix                 -> scalar_matrix_mul
            | scalar matrix_env             -> scalar_matrix_mul
            | product ("*" | "\\cdot" | "\\times" | "\\ast") implicit   -> mul
            | product "/" implicit                                      -> div
            | implicit

    ?implicit: implicit power        -> implicit_mul
             | power

    ?power: "-" power                -> neg
          | atom "^" power           -> power
          | atom

    ?atom: NUMBER                    -> number
         | SYMBOL                    -> symbol
         | derivative
         | matrix
         | matrix_env
         | "(" expr ")"
         | "\\left(" expr "\\right)"
         | row_op

    scalar: NUMBER | SYMBOL

    derivative: "\\frac" "{" "d" "}" "{" "d" SYMBOL "}" "(" expr ")"  -> derivative_dx_paren
              | "\\frac" "{" "d" "}" "{" "d" SYMBOL "}" "\\left(" expr "\\right)" -> derivative_dx_left

    matrix: "[" matrix_rows "]" -> matrix_rows
    matrix_rows: row ("," row)* -> matrix_rows
    row: "[" elements "]" -> row
    elements: expr ("," expr)* -> elements

    matrix_env: "\\begin" "{" /(bmatrix|pmatrix|matrix)/ "}" matrix_env_body "\\end" "{" /(bmatrix|pmatrix|matrix)/ "}" -> matrix_env

    matrix_env_body: matrix_env_row ( "\\\\" matrix_env_row )*
    matrix_env_row: expr ( "&" expr )*

    matrix_ops: matrix ("|" row_op)+ -> matrix_apply_ops

    row_op: "R_" INT arrow row_expr                 -> row_replace
          | "R_" INT swap_arrow "R_" INT            -> row_swap

    arrow: "\\to" | "\\leftarrow"
    swap_arrow: "\\leftrightarrow"

    row_expr: "R_" INT                     -> row_reference
             | expr "R_" INT               -> row_scale
             | "R_" INT op expr "R_" INT   -> row_combine

    op: "+" | "-"

    NUMBER: /[+-]?(\d+(\.\d*)?|\.\d+)([eE][+-]?\d+)?/
    SYMBOL: /\\?[a-zA-Z][a-zA-Z0-9_]*/
    INT: /[0-9]+/

    %import common.WS_INLINE
    %ignore WS_INLINE
    """
    
    def __init__(self):
        from lark import Lark
        self.parser = Lark(self.GRAMMAR, parser="earley", start="start")
        self.transformer = self._create_transformer()
    
    def _create_transformer(self):
        """Create the Lark transformer with improved rules"""
        from lark import Transformer, v_args
        import sympy as sp
        
        @v_args(inline=True)
        class Latex2Sympy(Transformer):
            def number(self, tok):
                s = str(tok)
                return sp.Integer(s) if '.' not in s else sp.Float(s)
            
            def symbol(self, tok):
                s = str(tok).strip()
                return sp.Symbol(s[1:] if s.startswith("\\") else s)
            
            def neg(self, v): 
                return sp.Mul(-1, v, evaluate=False)
            
            def add(self, a, b): 
                return sp.Add(a, b, evaluate=False)
            
            def sub(self, a, b): 
                return sp.Add(a, sp.Mul(-1, b, evaluate=False), evaluate=False)
            
            def mul(self, a, b):
                if isinstance(a, (sp.MatrixBase, sp.MatrixExpr)) or isinstance(b, (sp.MatrixBase, sp.MatrixExpr)):
                    a_ = sp.UnevaluatedExpr(a) if isinstance(a, (sp.MatrixBase, sp.MatrixExpr)) else a
                    b_ = sp.UnevaluatedExpr(b) if isinstance(b, (sp.MatrixBase, sp.MatrixExpr)) else b
                    return sp.Mul(a_, b_, evaluate=False)
                return sp.Mul(a, b, evaluate=True)
            
            def div(self, a, b): 
                return sp.Mul(a, sp.Pow(b, -1, evaluate=False), evaluate=False)
            
            def implicit_mul(self, a, b):
                if isinstance(a, sp.Matrix) or isinstance(b, sp.Matrix):
                    return sp.Mul(a, b, evaluate=False)
                return sp.Mul(a, b, evaluate=False)
            
            def power(self, a, b=None): 
                return sp.Pow(a, b, evaluate=False) if b else a
            
            def derivative_dx_paren(self, var, expr): 
                return sp.Derivative(expr, sp.Symbol(str(var)))
            
            def derivative_dx_left(self, var, expr): 
                return sp.Derivative(expr, sp.Symbol(str(var)))
            
            def elements(self, *items): 
                return list(items)
            
            def row(self, elements): 
                return list(elements) if isinstance(elements, (list, tuple)) else [elements]
            
            def matrix_rows(self, *rows):
                row_list = [list(r) if isinstance(r, (list, tuple)) else [r] for r in rows]
                return sp.Matrix(row_list)
            
            def matrix_env(self, *args):
                rows = []
                for a in args:
                    if a is None: 
                        continue
                    if isinstance(a, list) and a and all(isinstance(x, (list, tuple)) for x in a):
                        rows.extend([list(r) for r in a])
                    elif isinstance(a, (list, tuple)): 
                        rows.append(list(a))
                    else: 
                        rows.append([a])
                return sp.Matrix(rows)
            
            def scalar_matrix_mul(self, scalar, matrix):
                return sp.Mul(scalar, matrix, evaluate=False)
            
            def row_reference(self, i):
                return ("ref", int(i))
            
            def row_scale(self, factor, i):
                return ("scale", int(i), factor)
            
            def row_replace(self, target, expr):
                return ("replace", int(target), expr)
            
            def row_swap(self, i, j):
                return ("swap", int(i), int(j))
            
            def row_combine(self, i, op, factor, j):
                return ("combine", int(i), str(op), factor, int(j))
            
            def matrix_apply_ops(self, matrix, *ops):
                import sympy as sp
                m = sp.Matrix(matrix) if not isinstance(matrix, sp.Matrix) else matrix
                for op in ops:
                    if op[0] == "replace":
                        _, target, expr = op
                        if isinstance(expr, tuple):
                            if expr[0] == "ref":
                                m[target-1, :] = m[expr[1]-1, :]
                            elif expr[0] == "scale":
                                _, i, factor = expr
                                m[target-1, :] = factor * m[i-1, :]
                            elif expr[0] == "combine":
                                _, i, op_str, factor, j = expr
                                if op_str == "+":
                                    m[target-1, :] = m[i-1, :] + factor * m[j-1, :]
                                else:
                                    m[target-1, :] = m[i-1, :] - factor * m[j-1, :]
                    elif op[0] == "swap":
                        _, i, j = op
                        temp = m[i-1, :].copy()
                        m[i-1, :] = m[j-1, :]
                        m[j-1, :] = temp
                return m
            
            def start(self, e): 
                return e
        
        return Latex2Sympy()
    
    def clean_latex(self, tex):
        """Normalize LaTeX string for parsing"""
        import re
        if not tex:
            return ""
        t = (
            str(tex)
            .replace("\\left", "")
            .replace("\\right", "")
            .replace("\\mathrm{d}", "d")
        )
        # Remove spacing macros and whitespace
        t = re.sub(r"\\\\(?:,|;|:|!|quad|qquad| )", "", t)
        t = re.sub(r"\s+", "", t)
        return t.strip()
    
    def _show_error_popup(self, message):
        """Display error popup with close button"""
        safe_msg = message.replace("`", "'").replace("\\", "\\\\").replace("\n", "\\n")
        js_code = f"""
            (function(){{
                let existing = document.querySelector('#parseErrorPopup');
                if(existing) existing.remove();

                let popup = document.createElement('div');
                popup.id = 'parseErrorPopup';
                popup.style.cssText = `
                    position:fixed;
                    top:50%;
                    left:50%;
                    transform:translate(-50%, -50%);
                    background:#f8fafc;
                    color:#0f172a;
                    font-family:monospace;
                    padding:24px 24px 16px 24px;
                    border:2px solid #ef4444;
                    border-radius:12px;
                    box-shadow:0 12px 40px rgba(0,0,0,0.2);
                    white-space:pre;
                    z-index:9999;
                    max-width:650px;
                    max-height:70vh;
                    overflow:auto;
                `;

                let btn = document.createElement('button');
                btn.textContent = '✖';
                btn.title = 'Close';
                btn.style.cssText = `
                    position:absolute;
                    top:8px;
                    right:10px;
                    border:none;
                    background:transparent;
                    color:#ef4444;
                    font-size:18px;
                    font-weight:bold;
                    cursor:pointer;
                    line-height:1;
                `;
                btn.onclick = () => popup.remove();

                let content = document.createElement('div');
                content.textContent = `{safe_msg}`;
                content.style.paddingTop = '8px';

                popup.appendChild(btn);
                popup.appendChild(content);
                document.body.appendChild(popup);
            }})();
        """
        window.eval(js_code)
    
    def parse(self, latex):
        """Parse LaTeX to SymPy expression with error popup display"""
        import re
        from lark.exceptions import UnexpectedToken, UnexpectedCharacters, UnexpectedEOF
        
        clean = self.clean_latex(latex)
        try:
            tree = self.parser.parse(clean)
            result = self.transformer.transform(tree)
            return result
        
        except (UnexpectedToken, UnexpectedCharacters, UnexpectedEOF) as e:
            pos = getattr(e, "pos_in_stream", None)
            line = getattr(e, "line", "?")
            col = getattr(e, "column", "?")
            
            # Remove "Expected …" section from Lark message
            raw_msg = str(e)
            simplified_msg = re.sub(r"Expected one of:.*", "", raw_msg, flags=re.DOTALL).strip()
            
            # Build context with caret pointing to error
            try:
                span = 35
                start = max(0, (pos or 0) - span)
                end = min(len(clean), (pos or 0) + span)
                snippet = clean[start:end]
                caret_pos = (pos or 0) - start
                caret_line = " " * caret_pos + "↑"
                context = f"{snippet}\n{caret_line}"
            except Exception:
                context = clean
            
            msg = (
                f"❌ Parse error in LaTeX:\n\n"
                f"Line: {line}, Column: {col}\n"
                f"Type: {type(e).__name__}\n"
                f"Message: {simplified_msg}\n\n"
                f"Context:\n{context}"
            )
            self._show_error_popup(msg)
            window.console.error(msg)
            return None
        
        except Exception as e:
            msg = f"❌ General parse error: {e}"
            window.console.error(msg)
            self._show_error_popup(msg)
            return None
    
    def extract_structure(self, expr):
        """Extract structural fingerprint of expression"""
        import sympy as sp
        operators, operands = {}, {}

        def process(node, parent_op=None):
            if node is None:
                return
            if isinstance(node, (tuple, list)) and all(isinstance(i, sp.Integer) for i in node):
                return
            if isinstance(node, sp.MatrixBase):
                for el in node:
                    process(el, parent_op)
                return
            if isinstance(node, sp.MatrixExpr) and not isinstance(node, sp.MatrixBase):
                operands[str(node)] = operands.get(str(node), 0) + 1
                return
            if hasattr(node, "args") and len(node.args) > 0:
                op_name = type(node).__name__
                if op_name == "Tuple":
                    for c in node.args:
                        process(c, parent_op)
                    return
                if not (op_name == "Mul" and (parent_op == "Mul" or len(node.args) == 1)):
                    operators[op_name] = operators.get(op_name, 0) + 1
                for c in node.args:
                    process(c, op_name)
                return
            val = str(node).strip().replace(" ", "")
            if val == "-1":
                return
            operands[val] = operands.get(val, 0) + 1

        try:
            process(expr)
        except Exception as e:
            window.console.log(f"extract_structure error: {e}")
            #window.console.log(operators + "\n" + operands)
        return {
            "operators": operators, 
            "operands": operands,
            "total_ops": sum(operators.values()),
            "total_operands": sum(operands.values())
        }
    
    def normalize(self, expr):
        """Normalize and simplify expressions (compatible with ProblemSolverApp)"""
        import sympy as sp
        if expr is None:
            return None
        try:
            if hasattr(expr, "doit"):
                expr = expr.doit()
            if isinstance(expr, list):
                expr = sp.Matrix(expr)
            if isinstance(expr, sp.Matrix):
                expr = expr.applyfunc(sp.simplify)
            else:
                if isinstance(expr, sp.Mul) and not expr.is_Number:
                    args = expr.args
                    has_matrix = any(isinstance(a, sp.Matrix) for a in args)
                    has_scalar = any(not isinstance(a, sp.Matrix) for a in args)
                    if has_matrix and has_scalar:
                        return sp.Mul(*args, evaluate=True)
                expr = sp.simplify(expr)
        except:
            pass
        return expr
    
    def compare(self, a, b):
        """Check equality for scalar or matrix expressions (compatible with ProblemSolverApp)"""
        import sympy as sp
        try:
            if isinstance(a, sp.MatrixBase) and isinstance(b, sp.MatrixBase):
                if a.shape != b.shape:
                    return False
                for i in range(a.rows):
                    for j in range(a.cols):
                        if not sp.simplify(a[i, j] - b[i, j]) == 0:
                            return False
                return True
            if isinstance(a, sp.MatrixBase) and isinstance(b, list):
                return self.compare(a, sp.Matrix(b))
            if isinstance(b, sp.MatrixBase) and isinstance(a, list):
                return self.compare(sp.Matrix(a), b)
            return sp.simplify(a - b) == 0
        except:
            try:
                return a.equals(b)
            except:
                return False
class ProblemSolverApp:
    def __init__(self):
        self.problem_set = []
        self.problem_states = {}
        self.current_problem_index = None
        self.current_problem_set_uuid = None
        self.math_parser = MathParser()
        self.MQ = None
        self.current_page = "problems"
        # Import re at class level
        import re
        self.re = re
    
    def init(self):
        # Initialize MathQuill
        if hasattr(window, 'MathQuill'):
            self.MQ = window.MathQuill.getInterface(2)
        
        # Setup event listeners
        self.setup_events()
        
        # Load saved data
        self.load_from_storage()
        
        # Hide loading
        overlay = document.querySelector("#loadingOverlay")
        if overlay:
            overlay.style.opacity = "0"
            window.setTimeout(create_proxy(lambda: overlay.remove()), 400)
    
    def setup_events(self):
        # Navigation
        nav_items = document.querySelectorAll(".nav-item")
        for i in range(nav_items.length):
            item = nav_items[i]
            page = item.getAttribute("data-page")
            
            def make_nav_handler(p):
                def handler(e):
                    self.show_page(p)
                return handler
            
            item.addEventListener("click", create_proxy(make_nav_handler(page)))
        
        # Mobile menu
        menu_btn = document.querySelector("#menuBtn")
        if menu_btn:
            menu_btn.addEventListener("click", create_proxy(lambda e: self.toggle_sidebar(e)))
        
        overlay = document.querySelector("#sidebarOverlay")
        if overlay:
            overlay.addEventListener("click", create_proxy(lambda e: self.close_sidebar(e)))
        
        # Load buttons - FIXED: File upload should auto-process
        upload = document.querySelector("#uploadFile")
        if upload:
            upload.addEventListener("change", create_proxy(lambda e: self.handle_file_upload(e)))
        
        # Load JSON button for pasted text
        document.querySelector("#loadJsonBtn").addEventListener("click", create_proxy(lambda e: self.load_problems(e)))
        
        # Action buttons
        document.querySelector("#resetSolveBtn").addEventListener("click", create_proxy(lambda e: self.reset_current(e)))
        document.querySelector("#exportProgressBtn").addEventListener("click", create_proxy(lambda e: self.export_progress(e)))
        document.querySelector("#exportTelegramBtn").addEventListener("click", create_proxy(lambda e: self.export_telegram(e)))
        document.querySelector("#clearStorageBtn").addEventListener("click", create_proxy(lambda e: self.clear_all(e)))
    
    def show_page(self, page_name):
        # Hide all pages
        pages = document.querySelectorAll(".page")
        for i in range(pages.length):
            pages[i].classList.remove("active")
        
        # Show selected page
        target = document.querySelector(f"#{page_name}Page")
        if target:
            target.classList.add("active")
        
        # Update nav
        nav_items = document.querySelectorAll(".nav-item")
        for i in range(nav_items.length):
            nav_items[i].classList.remove("active")
        
        active_nav = document.querySelector(f".nav-item[data-page='{page_name}']")
        if active_nav:
            active_nav.classList.add("active")
        
        self.current_page = page_name
        self.close_sidebar(None)
    
    def toggle_sidebar(self, event):
        sidebar = document.querySelector("#sidebar")
        overlay = document.querySelector("#sidebarOverlay")
        if sidebar and sidebar.classList.contains("open"):
            self.close_sidebar(event)
        else:
            if sidebar:
                sidebar.classList.add("open")
            if overlay:
                overlay.classList.add("show")
    
    def close_sidebar(self, event):
        sidebar = document.querySelector("#sidebar")
        overlay = document.querySelector("#sidebarOverlay")
        if sidebar:
            sidebar.classList.remove("open")
        if overlay:
            overlay.classList.remove("show")
    
    def extract_base64(self, text):
        # FIXED: Use self.re instead of importing re
        text = str(text).strip()
        
        # Check if it's an export format
        if "=== STUDENT PROGRESS EXPORT ===" in text:
            pattern = r"===.*?EXPORT.*?===(.*?)(?:===|$)"
            matches = self.re.findall(pattern, text, self.re.DOTALL)
            if matches:
                extracted = self.re.sub(r"[\s\r\n]+", "", "".join(matches))
                # Validate base64
                if self.is_valid_base64(extracted):
                    return extracted
        
        # Check if it's plain base64
        cleaned = self.re.sub(r"[\s\r\n]+", "", text)
        if self.is_valid_base64(cleaned):
            return cleaned
        
        return None
    
    def is_valid_base64(self, s):
        """Check if string is valid base64"""
        if not s:
            return False
        
        # Base64 should only contain these characters
        base64_pattern = r'^[A-Za-z0-9+/]*={0,2}$'
        if not self.re.match(base64_pattern, s):
            return False
        
        # Length should be divisible by 4
        if len(s) % 4 != 0:
            return False
        
        return True
    
    def handle_file_upload(self, event):
        # FIXED: This should automatically process the file
        files = event.target.files
        if files and files.length > 0:
            file = files.item(0)
            from js import FileReader
            reader = FileReader.new()
            def on_load(e):
                try:
                    content = e.target.result
                    window.console.log(f"File content length: {len(content)}")
                    window.console.log(f"File content preview: {content[:200]}...")
                    
                    base64 = self.extract_base64(content)
                    if base64:
                        window.console.log(f"Extracted base64 length: {len(base64)}")
                        self.decode_and_load(base64)
                        # Clear the file input after successful upload
                        event.target.value = ""
                        # Show success message
                        self.show_indicator("📁 File uploaded successfully", "#10b981")
                    else:
                        window.alert("❌ No valid base64 data found in file. Please ensure the file contains exported problem data.")
                except Exception as ex:
                    window.console.error(f"Error processing file: {ex}")
                    window.alert(f"❌ Error processing file: {ex}")
            reader.onload = create_proxy(on_load)
            reader.readAsText(file)
    
    def generate_minimal_buttons(self, step_data):
        """Generate minimal button set based on expression and expected structure"""
        
        # Parse expression to extract symbols
        expression_latex = step_data.get("expression", "")
        expected_struct = step_data.get("expected_structure", {})
        
        buttons = set()
        
        # Extract operands from expected structure
        expected_operands = expected_struct.get("operands", {})
        expected_operators = expected_struct.get("operators", {})
        
        # DEBUG: Log structure to see what we're working with
        window.console.log(f"Expected operands: {expected_operands}")
        window.console.log(f"Expected operators: {expected_operators}")
        window.console.log(f"Expression: {expression_latex}")
        
        # Add ONLY the specific digits needed from operands, plus limited distractors
        required_digits = set()
        has_decimal = False
        has_negative = False
        
        for operand in expected_operands.keys():
            if self._is_numeric(operand):
                # Check for negative numbers
                if str(operand).startswith("-"):
                    has_negative = True
                # Extract individual digits from the number
                num_str = str(operand).replace("-", "").replace(".", "")
                for digit in num_str:
                    if digit.isdigit():
                        required_digits.add(digit)
                # Check if decimal point is needed
                if "." in str(operand):
                    has_decimal = True
        
        # Add required digits
        for digit in required_digits:
            buttons.add(("digit", digit, digit))
        
        # Add 2-3 distractor digits (digits NOT in the answer)
        all_digits = set("0123456789")
        available_distractors = list(all_digits - required_digits)
        
        if available_distractors:
            import random
            random.seed(hash(expression_latex))  # Consistent distractors per step
            num_distractors = min(3, len(available_distractors))
            distractors = random.sample(available_distractors, num_distractors)
            for digit in distractors:
                buttons.add(("digit", digit, digit))
        
        # Add decimal point if needed
        if has_decimal:
            buttons.add(("special", ".", "."))
        
        # Add negative sign if needed (but not if subtraction operator already present)
        if has_negative and "Add" not in expected_operators:
            buttons.add(("operator", "−", "-"))
        
        # Add variables/symbols from operands
        for operand in expected_operands.keys():
            if not self._is_numeric(operand) and operand != "-1":
                # Clean symbol name (remove backslashes)
                clean_sym = operand.replace("\\", "")
                if len(clean_sym) <= 3:  # Only add short symbols as buttons
                    buttons.add(("symbol", clean_sym, clean_sym))
        
        # Add operators based on expected structure
        operator_map = {
            "Add": ("+", "+"),
            "Mul": ("×", "\\times"),
            "Pow": ("^", "^"),
            "Derivative": ("d/dx", "SEQ:d,/,d,x"),
            "sin": ("sin", "\\sin"),
            "cos": ("cos", "\\cos"),
            "tan": ("tan", "\\tan"),
            "cot": ("cot", "\\cot"),
            "sec": ("sec", "\\sec"),
            "csc": ("csc", "\\csc"),
            "log": ("log", "\\log"),
            "ln": ("ln", "\\ln"),
            "exp": ("exp", "\\exp"),
            "sqrt": ("√", "\\sqrt"),
            "Abs": ("|x|", "\\left|"),
            "factorial": ("!", "!"),
        }
        
        for op in expected_operators.keys():
            if op in operator_map:
                label, latex = operator_map[op]
                buttons.add(("operator", label, latex))
        
        # Additional operator detection from expression itself
        # Check for derivative notation
        if "\\frac{d}{dx}" in expression_latex or "\\frac{d}{d" in expression_latex or "Derivative" in str(expected_operators):
            buttons.add(("operator", "d/dx", "SEQ:d,/,d,x"))
            window.console.log("Added derivative button")
        
        # Check for multiplication symbols
        if "\\cdot" in expression_latex or "\\times" in expression_latex or "·" in expression_latex or "*" in expression_latex or "Mul" in expected_operators:
            if ("operator", "×", "\\times") not in buttons:
                buttons.add(("operator", "×", "\\times"))
                window.console.log("Added multiplication button")
        
        # Check for division symbols
        if "/" in expression_latex or "\\div" in expression_latex or "÷" in expression_latex:
            buttons.add(("operator", "÷", "/"))
            window.console.log("Added division button from expression")
        
        # Check if division is also needed (represented as Mul with Pow(-1))
        if "Mul" in expected_operators and "Pow" in expected_operators:
            buttons.add(("operator", "÷", "/"))
        
        # Check for subtraction (represented as Add with Mul(-1))
        if "Add" in expected_operators:
            buttons.add(("operator", "−", "-"))
        
        # Always add parentheses, power, and subscript if there are operators
        if expected_operators or len(required_digits) > 1:
            buttons.add(("special", "(", "("))
            buttons.add(("special", ")", ")"))
            buttons.add(("special", "xʸ", "^"))
            buttons.add(("special", "xᵧ", "_"))
        
        # Check if matrix notation is needed - IMPROVED DETECTION
        needs_matrix = False
        
        # Check operators for matrix operations
        matrix_operators = ["MatMul", "MatAdd", "Transpose", "Inverse", "Determinant"]
        if any(op in expected_operators for op in matrix_operators):
            needs_matrix = True
            window.console.log("Matrix detected from operators")
        
        # Check operands for matrix notation
        if not needs_matrix:
            for operand in expected_operands.keys():
                operand_str = str(operand)
                if "Matrix" in operand_str or "[" in operand_str or "," in operand_str:
                    needs_matrix = True
                    window.console.log(f"Matrix detected from operand: {operand_str}")
                    break
        
        # Check expression itself for matrix notation
        if not needs_matrix and "[" in expression_latex:
            needs_matrix = True
            window.console.log("Matrix detected from expression")
        
        # Add matrix buttons if needed
        if needs_matrix:
            window.console.log("Adding matrix brackets and comma")
            buttons.add(("special", "[", "["))
            buttons.add(("special", "]", "]"))
            buttons.add(("special", ",", ","))
        
        # Check if fraction notation is needed
        if "Mul" in expected_operators and "Pow" in expected_operators:
            buttons.add(("special", "÷", "\\frac"))
        
        # Add navigation buttons for MathQuill field
        buttons.add(("navigation", "◄", "MOVE_LEFT"))
        buttons.add(("navigation", "►", "MOVE_RIGHT"))
        buttons.add(("navigation", "⇤", "SELECT_LEFT"))
        buttons.add(("navigation", "⇥", "SELECT_RIGHT"))

        
        # Always add backspace and clear
        buttons.add(("delete", "⌫", "BACKSPACE"))
        buttons.add(("delete", "Clear", "CLEAR"))
        # Add keyboard activation button
        buttons.add(("navigation", "⌨️", "ACTIVATE_KEYBOARD"))
        buttons.add(("navigation", "🔒", "DEACTIVATE_KEYBOARD"))
        
        # Sort buttons by type and label
        sorted_buttons = sorted(buttons, key=lambda x: (
            0 if x[0] == "digit" else
            1 if x[0] == "symbol" else
            2 if x[0] == "operator" else
            3 if x[0] == "special" else
            4 if x[0] == "navigation" else
            5 if x[0] == "delete" else 6,
            x[1]
        ))
        
        html_parts = []
        for btn_type, label, action in sorted_buttons:
            safe_label = html.escape(label)
            html_parts.append(
                f"<button class='input-btn {btn_type}' data-action='{action}'>{safe_label}</button>"
            )
        
        return "\n".join(html_parts)
    
    def _is_numeric(self, s):
        """Check if string represents a number"""
        try:
            float(str(s))
            return True
        except (ValueError, TypeError):
            return False
    
    def handle_input_button(self, step_idx, action, answer_field):
        """Handle minimal button clicks to input into MathQuill field"""
        # Get the correct answer field from solve_state using step_idx
        if not hasattr(self, 'solve_state') or step_idx >= len(self.solve_state):
            window.console.error(f"Invalid step_idx: {step_idx}")
            return
        
        # Always get the field from solve_state to ensure we have the right one
        step = self.solve_state[step_idx]
        answer_field = step.get("answer_mf")
        
        if not answer_field:
            window.console.error(f"No answer field for step {step_idx}")
            return
        
        if action == "BACKSPACE":
            answer_field.keystroke("Backspace")
        elif action == "CLEAR":
            answer_field.latex("")
        elif action == "MOVE_LEFT":
            answer_field.keystroke("Left")
        elif action == "MOVE_RIGHT":
            answer_field.keystroke("Right")
        elif action == "SELECT_LEFT":
            answer_field.keystroke("Shift-Left")
        elif action == "SELECT_RIGHT":
            answer_field.keystroke("Shift-Right")
        elif action == "ACTIVATE_KEYBOARD":
            # Enable keyboard input by focusing the field
            try:
                el = answer_field.el()
                textarea = el.querySelector('textarea')
                if textarea:
                    textarea.style.width = f"{el.offsetWidth}px"
                    textarea.style.height = f"{el.offsetHeight}px"
                    textarea.style.overflow = "hidden"
                    textarea.style.resize = "none"
                    textarea.style.boxSizing = "border-box"
                    if textarea:

                    # Temporarily enable the textarea
                        textarea.removeAttribute('readonly')
                        textarea.removeAttribute('disabled')
                        textarea.style.pointerEvents = 'auto'
                        textarea.style.opacity = '1'
                        textarea.style.position = 'absolute'  # optional
                        textarea.style.left = '0'
                        textarea.style.width = f"{el.offsetWidth}px"
                        textarea.style.height = f"{el.offsetHeight}px"
                        textarea.style.overflow = 'hidden'
                        textarea.style.resize = 'none'
                        textarea.focus()
                    # Focus it to show keyboard
                    textarea.focus()
                    window.console.log(f"✅ Keyboard activated for step {step_idx}")
            except Exception as e:
                window.console.error(f"Failed to activate keyboard for step {step_idx}: {e}")
        elif action == "DEACTIVATE_KEYBOARD":
            # Disable keyboard input by blurring and hiding the field
            try:
                el = answer_field.el()
                textarea = el.querySelector('textarea')
                if textarea:
                    textarea.blur()
                    textarea.setAttribute('readonly', 'readonly')
                    textarea.setAttribute('disabled', 'disabled')
                    textarea.style.pointerEvents = 'none'
                    textarea.style.opacity = '0'
                    textarea.style.position = 'absolute'
                    textarea.style.left = '-9999px'
                    window.console.log(f"✅ Keyboard deactivated for step {step_idx}")
            except Exception as e:
                window.console.error(f"Failed to deactivate keyboard for step {step_idx}: {e}")
        elif action == "^":
            # Power button - use cmd for exponent
            answer_field.cmd("^")
        elif action == "_":
            # Subscript button - use cmd for subscript
            answer_field.cmd("_")
        elif action.startswith("SEQ:"):
            # Handle key sequences (e.g., SEQ:d,/,d,x)
            sequence = action[4:]  # Remove "SEQ:" prefix
            keys = sequence.split(",")
            for key in keys:
                key = key.strip()
                if key == "/":
                    answer_field.cmd("/")
                elif key.startswith("\\"):
                    answer_field.cmd(key)
                else:
                    answer_field.write(key)
        else:
            # Insert the LaTeX command or character
            if action.startswith("\\"):
                answer_field.cmd(action)
            else:
                answer_field.write(action)

    def validate_problem_set(self, problems):
        """
        Validate that all problems have expected_structure.
        Returns (is_valid, error_messages)
        """
        errors = []

        for p_idx, problem in enumerate(problems, start=1):
            steps = problem.get("steps", [])
            if not steps:
                errors.append(f"Problem {p_idx}: No steps found")
                continue

            for s_idx, step in enumerate(steps, start=1):
                # Check if expected_structure exists
                expected_struct = step.get("expected_structure")

                if expected_struct is None:
                    errors.append(f"Problem {p_idx}, Step {s_idx}: Missing expected_structure")
                    continue

                # Validate structure has required fields
                if not isinstance(expected_struct, dict):
                    errors.append(f"Problem {p_idx}, Step {s_idx}: expected_structure is not a dictionary")
                    continue

                if "operators" not in expected_struct or "operands" not in expected_struct:
                    errors.append(f"Problem {p_idx}, Step {s_idx}: expected_structure missing operators or operands")
                    continue

                # Warn if structure is empty (might be intentional for simple answers)
                if not expected_struct.get("operators") and not expected_struct.get("operands"):
                    window.console.log(f"Warning: Problem {p_idx}, Step {s_idx} has empty structure")

        return (len(errors) == 0, errors)

    def _show_validation_error_popup(self, message):
        """Display detailed validation error popup"""
        safe_msg = str(message).replace("`", "'").replace("\\", "\\\\").replace("\n", "\\n")
        js_code = f"""
            (function(){{
                let existing = document.querySelector('#validationErrorPopup');
                if(existing) existing.remove();

                let popup = document.createElement('div');
                popup.id = 'validationErrorPopup';
                popup.style.cssText = `
                    position:fixed;
                    top:50%;
                    left:50%;
                    transform:translate(-50%, -50%);
                    background:#fef2f2;
                    color:#991b1b;
                    font-family:system-ui, -apple-system, sans-serif;
                    padding:24px 24px 16px 24px;
                    border:3px solid #dc2626;
                    border-radius:12px;
                    box-shadow:0 12px 40px rgba(220, 38, 38, 0.3);
                    white-space:pre-wrap;
                    z-index:9999;
                    max-width:700px;
                    max-height:80vh;
                    overflow:auto;
                `;

                let btn = document.createElement('button');
                btn.textContent = '✖';
                btn.title = 'Close';
                btn.style.cssText = `
                    position:absolute;
                    top:8px;
                    right:10px;
                    border:none;
                    background:transparent;
                    color:#dc2626;
                    font-size:20px;
                    font-weight:bold;
                    cursor:pointer;
                    line-height:1;
                `;
                btn.onclick = () => popup.remove();

                let title = document.createElement('h3');
                title.textContent = '❌ Problem Set Validation Failed';
                title.style.cssText = 'margin:0 0 16px 0;color:#991b1b;font-size:18px;';

                let content = document.createElement('div');
                content.textContent = `{safe_msg}`;
                content.style.cssText = 'font-family:monospace;font-size:13px;line-height:1.6;';

                let note = document.createElement('div');
                note.innerHTML = '<br><strong>Note:</strong> This problem set is missing required structure data. Please ensure it was exported from a compatible version of the Problem Creator app.';
                note.style.cssText = 'margin-top:16px;padding:12px;background:#fee2e2;border-radius:6px;font-size:13px;';

                popup.appendChild(btn);
                popup.appendChild(title);
                popup.appendChild(content);
                popup.appendChild(note);
                document.body.appendChild(popup);
            }})();
        """
        window.eval(js_code)
    
    def decode_and_load(self, base64text):
        try:
            window.console.log("Attempting to decode base64...")

            # Validate base64 before decoding
            if not self.is_valid_base64(base64text):
                raise ValueError("Invalid base64 format")

            # Try to decode base64
            try:
                import brotli, base64
                compressed = base64.b64decode(base64text)
                window.console.log(f"Successfully decoded base64, compressed size: {len(compressed)} bytes")

                # Try to decompress
                try:
                    json_text = brotli.decompress(compressed).decode("utf-8")
                    window.console.log(f"Successfully decompressed, JSON length: {len(json_text)}")
                except Exception as decompress_error:
                    window.console.error(f"Brotli decompression failed: {decompress_error}")
                    # Try without brotli (maybe it's just plain JSON)
                    try:
                        json_text = compressed.decode("utf-8")
                        window.console.log("Using plain JSON (no compression)")
                    except Exception as plain_error:
                        raise ValueError(f"Neither brotli nor plain JSON worked: {plain_error}")

            except Exception as decode_error:
                window.console.error(f"Base64 decode failed: {decode_error}")
                raise ValueError(f"Base64 decode failed: {decode_error}")

            # Parse JSON
            try:
                data = json.loads(json_text)
                window.console.log(f"Successfully parsed JSON, type: {type(data)}")
            except json.JSONDecodeError as json_error:
                window.console.error(f"JSON parse error: {json_error}")
                window.console.error(f"JSON content preview: {json_text[:500]}...")
                raise ValueError(f"Invalid JSON format: {json_error}")

            # Handle different formats
            if isinstance(data, dict) and "problems" in data:
                problems = data["problems"]
                self.current_problem_set_uuid = data.get("problem_set_id", str(uuid.uuid4()))
                description = data.get("problem_set_description", "")
            else:
                problems = data if isinstance(data, list) else []
                self.current_problem_set_uuid = str(uuid.uuid4())
                description = ""

            if not problems:
                raise ValueError("No problems found in data")

            # ⭐ NEW: Validate problem set structure
            is_valid, errors = self.validate_problem_set(problems)
            if not is_valid:
                error_msg = "❌ Invalid problem set format:\n\n" + "\n".join(errors[:15])
                if len(errors) > 15:
                    error_msg += f"\n\n...and {len(errors) - 15} more errors"

                # Show detailed error popup
                self._show_validation_error_popup(error_msg)
                raise ValueError(f"Problem set validation failed: {len(errors)} error(s)")

            self.problem_set = problems
            self.problem_states = {}
            self.current_problem_index = None

            # Update UI
            self.update_problem_set_info(description)
            self.render_problems()
            self.save_to_storage()

            window.alert(f"✅ Loaded {len(problems)} problems")
            self.show_page("problems")

        except ValueError as ve:
            window.console.error(f"ValueError: {ve}")
            window.alert(f"❌ Invalid data format: {ve}")
        except Exception as e:
            window.console.error(f"General error: {e}")
            window.alert(f"❌ Failed to load: {e}")    
    def update_problem_set_info(self, description):
        info_panel = document.querySelector("#problemSetInfo")
        desc_el = document.querySelector("#currentProblemSetDescription")
        uuid_el = document.querySelector("#currentProblemSetUuid")
        
        if self.problem_set:
            info_panel.style.display = "block"
            desc_el.textContent = description or "No description"
            uuid_el.textContent = self.current_problem_set_uuid
        else:
            info_panel.style.display = "none"
    
    def render_problems(self):
        container = document.querySelector("#solveProblemsContainer")
        if not container:
            return
        container.innerHTML = ""
        
        # Hide initial panel
        initial_panel = document.querySelector("#initialLoadPanel")
        if initial_panel:
            initial_panel.style.display = "none"
        
        for idx, prob in enumerate(self.problem_set):
            title = prob.get("title", f"Problem {idx+1}")
            steps = prob.get("steps", [])
            total = len(steps)
            
            prob_state = self.problem_states.get(idx, [])
            finalized = sum(1 for s in prob_state if s.get("finalized", False))
            is_done = finalized == total and total > 0
            
            accordion = document.createElement("div")
            accordion.className = "accordion-problem"
            accordion.setAttribute("data-index", idx)
            
            if is_done:
                accordion.classList.add("finished")
            
            header = document.createElement("div")
            header.className = "accordion-header"
            progress_color = "#059669" if is_done else "#6b7280"
            header.innerHTML = f"<span>{idx+1}. {title}</span><span class='progress-summary' style='color:{progress_color}'>✅ {finalized}/{total} completed</span>"
            
            body = document.createElement("div")
            body.className = "accordion-body"
            body.id = f"problemBody{idx}"
            
            accordion.appendChild(header)
            accordion.appendChild(body)
            container.appendChild(accordion)
            
            def make_toggle_handler(i):
                def handler(e):
                    self.toggle_problem(i)
                return handler
            
            header.addEventListener("click", create_proxy(make_toggle_handler(idx)))
        
        # Auto-open first or current problem
        open_idx = self.current_problem_index or 0
        if open_idx < len(self.problem_set):
            self.toggle_problem(open_idx)
    
    def toggle_problem(self, index):
        """Toggle accordion and switch active problem with proper state management"""

        window.console.log(f"=== Toggle problem called: index={index}, current={self.current_problem_index} ===")

        # Get the accordion element
        acc = document.querySelector(f".accordion-problem[data-index='{index}']")
        if not acc:
            window.console.error(f"Accordion {index} not found")
            return

        # Check if clicking on an already open accordion - close it
        if acc.classList.contains("open"):
            window.console.log(f"Accordion {index} is already open, closing it")
            acc.classList.remove("open")
            return

        # ✅ STEP 1: Save current problem state if switching away
        if self.current_problem_index is not None and self.current_problem_index != index and hasattr(self, 'solve_state'):
            window.console.log(f"Saving state for problem {self.current_problem_index} before switching")

            serializable_state = []
            for step in self.solve_state:
                step_data = {
                    "step": step.get("step", {}),
                    "attempts": step.get("attempts", 0),
                    "attempt_history": step.get("attempt_history", []),
                    "correct": step.get("correct", False),
                    "finalize_attempts": step.get("finalize_attempts", 0),
                    "finalize_history": step.get("finalize_history", []),
                    "structure_correct": step.get("structure_correct", False),
                    "finalized": step.get("finalized", False),
                    "step_start_time": step.get("step_start_time", window.Date.now())
                }
                serializable_state.append(step_data)

            self.problem_states[self.current_problem_index] = serializable_state
            window.console.log(f"✅ Saved {len(serializable_state)} steps for problem {self.current_problem_index}")

        # ✅ STEP 2: Close all accordions
        accordions = document.querySelectorAll(".accordion-problem")
        for i in range(accordions.length):
            accordions[i].classList.remove("open")

        # ✅ STEP 3: Open selected accordion
        acc.classList.add("open")
        body = acc.querySelector(".accordion-body")

        if not body:
            window.console.error(f"Accordion body {index} not found")
            return

        # ✅ STEP 4: Load problem content
        # Check if we need to reload (first time or switching problems)
        needs_reload = (not body.hasAttribute("data-loaded")) or (self.current_problem_index != index)

        if needs_reload:
            window.console.log(f"Loading problem {index} content")
            self.load_problem(index, body)
            body.setAttribute("data-loaded", "true")
            window.console.log(f"✅ Problem {index} loaded, current_problem_index is now {self.current_problem_index}")
        else:
            window.console.log(f"Problem {index} already loaded, just updating index")
            self.current_problem_index = index

        # ✅ STEP 5: Verify state is correct
        window.console.log(f"Final state check: current_problem_index={self.current_problem_index}, solve_state length={len(self.solve_state) if hasattr(self, 'solve_state') else 0}")
    def load_problem(self, index, container):
        """Load a problem and restore its state"""

        # ✅ SET CURRENT INDEX IMMEDIATELY
        window.console.log(f"Loading problem {index}, previous was {self.current_problem_index}")
        self.current_problem_index = index

        prob = self.problem_set[index]
        steps = prob.get("steps", [])

        container.innerHTML = ""
        
        # Description - display both title and description content at problem level
        desc_div = document.createElement("div")
        desc_div.className = "problem-description"
        desc_div.style.cssText = "background:#f0f9ff;padding:16px;border-radius:8px;margin-bottom:16px;"
        
        # Add title
        title_html = f"<h4 style='margin:0 0 12px 0;'>{html.escape(prob.get('title', 'Problem'))}</h4>"
        
        # Add problem description content if it exists
        prob_desc_content = prob.get("description", "")
        prob_desc_html = ""
        
        if prob_desc_content:
            window.console.log(f"Problem description type: {type(prob_desc_content)}")
            # Check if description is a list of blocks (like step descriptions)
            if isinstance(prob_desc_content, (list, tuple)):
                for blk in prob_desc_content:
                    if isinstance(blk, dict):
                        if blk.get("type") == "text":
                            prob_desc_html += blk.get("value", "")
                        elif blk.get("type") == "math":
                            latex_content = blk.get('latex', '')
                            
                            window.console.log(f"Problem desc: Raw latex_content = {latex_content}, type = {type(latex_content)}")
                            
                            # Check if it's a Python list (direct list object)
                            if isinstance(latex_content, (list, tuple)):
                                window.console.log(f"Problem desc: Direct list matrix")
                                rows = []
                                for row in latex_content:
                                    if isinstance(row, (list, tuple)):
                                        rows.append(" & ".join(str(x) for x in row))
                                    else:
                                        rows.append(str(row))
                                latex_matrix = r"\begin{bmatrix}" + r" \\ ".join(rows) + r"\end{bmatrix}"
                                prob_desc_html += f"$${latex_matrix}$$"
                            
                            # Check if string contains matrix pattern with \left[ wrappers
                            elif isinstance(latex_content, str) and r"\left[" in latex_content and r"\right]" in latex_content:
                                window.console.log(f"Problem desc: String with LaTeX matrix wrappers")
                                import re
                                # Remove \left[ and \right] and extract the content
                                cleaned = latex_content.replace(r"\left[", "[").replace(r"\right]", "]")
                                window.console.log(f"Problem desc: Cleaned = {cleaned}")
                                
                                # Try to find [[...]] pattern
                                matrix_match = re.search(r'\[\[.*?\]\]', cleaned)
                                if matrix_match:
                                    matrix_str = matrix_match.group(0)
                                    window.console.log(f"Problem desc: Found matrix string = {matrix_str}")
                                    try:
                                        import json
                                        matrix_data = json.loads(matrix_str)
                                        rows = []
                                        for row in matrix_data:
                                            if isinstance(row, (list, tuple)):
                                                rows.append(" & ".join(str(x) for x in row))
                                            else:
                                                rows.append(str(row))
                                        latex_matrix = r"\begin{bmatrix}" + r" \\ ".join(rows) + r"\end{bmatrix}"
                                        window.console.log(f"Problem desc: Converted to LaTeX = {latex_matrix}")
                                        
                                        # Check if there's additional content after the matrix
                                        remaining = cleaned.replace(matrix_str, "", 1)
                                        prob_desc_html += f"$${latex_matrix}{remaining}$$"
                                    except Exception as e:
                                        window.console.error(f"Problem desc: JSON parse failed: {e}")
                                        prob_desc_html += f"\\({latex_content}\\)"
                                else:
                                    # No matrix pattern found, use as-is
                                    prob_desc_html += f"\\({latex_content}\\)"
                            
                            # Check if plain string starts with [[
                            elif isinstance(latex_content, str) and latex_content.strip().startswith('[['):
                                window.console.log(f"Problem desc: Plain JSON matrix string")
                                try:
                                    import json
                                    matrix_data = json.loads(latex_content)
                                    rows = []
                                    for row in matrix_data:
                                        rows.append(" & ".join(str(x) for x in row))
                                    latex_matrix = r"\begin{bmatrix}" + r" \\ ".join(rows) + r"\end{bmatrix}"
                                    prob_desc_html += f"$${latex_matrix}$$"
                                except Exception as e:
                                    window.console.error(f"Problem desc: matrix parse error: {e}")
                                    prob_desc_html += f"\\({latex_content}\\)"
                            
                            else:
                                # Regular LaTeX string
                                window.console.log(f"Problem desc: Regular LaTeX")
                                prob_desc_html += f"\\({latex_content}\\)"
            elif isinstance(prob_desc_content, str):
                # Plain string description
                prob_desc_html = prob_desc_content
        
        desc_div.innerHTML = title_html + prob_desc_html
        container.appendChild(desc_div)
        
        self.solve_state = []
        
        for step_idx, step_data in enumerate(steps):
            step_div = document.createElement("div")
            step_div.className = "panel step"
            step_div.style.display = "none"
            
            step_desc = step_data.get("description", [])
            desc_html = ""
            for blk in step_desc:
                if blk["type"] == "text":
                    desc_html += blk["value"]
                elif blk["type"] == "math":
                    latex_content = blk.get('latex', '')
                    
                    window.console.log(f"Step {step_idx}: Raw latex_content = {latex_content}, type = {type(latex_content)}")
                    
                    # Check if it's a Python list (direct list object)
                    if isinstance(latex_content, (list, tuple)):
                        window.console.log(f"Step {step_idx}: Direct list matrix")
                        rows = []
                        for row in latex_content:
                            if isinstance(row, (list, tuple)):
                                rows.append(" & ".join(str(x) for x in row))
                            else:
                                rows.append(str(row))
                        latex_matrix = r"\begin{bmatrix}" + r" \\ ".join(rows) + r"\end{bmatrix}"
                        desc_html += f"$${latex_matrix}$$"
                    
                    # Check if string contains matrix pattern with \left[ wrappers
                    elif isinstance(latex_content, str) and r"\left[" in latex_content and r"\right]" in latex_content:
                        window.console.log(f"Step {step_idx}: String with LaTeX matrix wrappers")
                        import re
                        # Remove \left[ and \right] and extract the content
                        cleaned = latex_content.replace(r"\left[", "[").replace(r"\right]", "]")
                        window.console.log(f"Step {step_idx}: Cleaned = {cleaned}")
                        
                        # Try to find [[...]] pattern
                        matrix_match = re.search(r'\[\[.*?\]\]', cleaned)
                        if matrix_match:
                            matrix_str = matrix_match.group(0)
                            window.console.log(f"Step {step_idx}: Found matrix string = {matrix_str}")
                            try:
                                import json
                                matrix_data = json.loads(matrix_str)
                                rows = []
                                for row in matrix_data:
                                    if isinstance(row, (list, tuple)):
                                        rows.append(" & ".join(str(x) for x in row))
                                    else:
                                        rows.append(str(row))
                                latex_matrix = r"\begin{bmatrix}" + r" \\ ".join(rows) + r"\end{bmatrix}"
                                window.console.log(f"Step {step_idx}: Converted to LaTeX = {latex_matrix}")
                                
                                # Check if there's additional content after the matrix (like \cdot3)
                                remaining = cleaned.replace(matrix_str, "", 1)
                                desc_html += f"$${latex_matrix}{remaining}$$"
                            except Exception as e:
                                window.console.error(f"Step {step_idx}: JSON parse failed: {e}")
                                desc_html += f"\\({latex_content}\\)"
                        else:
                            # No matrix pattern found, use as-is
                            desc_html += f"\\({latex_content}\\)"
                    
                    # Check if plain string starts with [[
                    elif isinstance(latex_content, str) and latex_content.strip().startswith('[['):
                        window.console.log(f"Step {step_idx}: Plain JSON matrix string")
                        try:
                            import json
                            matrix_data = json.loads(latex_content)
                            rows = []
                            for row in matrix_data:
                                rows.append(" & ".join(str(x) for x in row))
                            latex_matrix = r"\begin{bmatrix}" + r" \\ ".join(rows) + r"\end{bmatrix}"
                            desc_html += f"$${latex_matrix}$$"
                        except Exception as e:
                            window.console.error(f"Step {step_idx}: matrix parse error: {e}")
                            desc_html += f"\\({latex_content}\\)"
                    
                    else:
                        # Regular LaTeX string
                        window.console.log(f"Step {step_idx}: Regular LaTeX")
                        desc_html += f"\\({latex_content}\\)"
            
            window.console.log(f"Step {step_idx} final desc_html: {desc_html}")
            
            # ⭐ GENERATE MINIMAL BUTTONS
            button_html = self.generate_minimal_buttons(step_data)
            
            step_div.innerHTML = f"""
            <div style='font-weight:700;margin-bottom:10px;'>Step {step_idx+1} of {len(steps)}</div>
            <div class='step-description'>{desc_html}</div>
            <div style='margin-top:14px;'>
              <div style='font-weight:700;margin-bottom:8px;'>Your Answer:</div>
              <div class='math-input step-answer'></div>
              <div style='margin-top:14px;'>
                <div style='font-weight:600;margin-bottom:8px;font-size:14px;'>Input Buttons:</div>
                <div class='button-grid' style='display:grid;grid-template-columns:repeat(auto-fill,minmax(50px,1fr));gap:6px;margin-bottom:12px;'>
                  <button class='input-btn navigation' data-action='ACTIVATE_KEYBOARD'>⌨️</button>
                  <button class='input-btn navigation' data-action='DEACTIVATE_KEYBOARD'>🔒</button>
                  {button_html}
                </div>
              </div>
              <div style='display:flex;flex-direction:column;gap:8px;margin-top:10px;'>
                <button class='btn submitAnswer'>Submit Answer</button>
                <button class='btn ghost finalizeStep' disabled>Finalize Step</button>
                <button class='btn nextStep' style='display:none;background:#10b981;'>Next Step →</button>
              </div>
            </div>
            <div class='step-feedback'></div>
            <div class='attempts-history' style='display:none;'></div>
            """
            
            container.appendChild(step_div)
            
            # Initialize MathQuill
            if self.MQ:
                answer_field = self.MQ.MathField(step_div.querySelector(".step-answer"))
                
                """
                # GLOBALLY DISABLE TEXTAREA TO PREVENT ANDROID KEYBOARD
                try:
                    el = answer_field.el()
                    textarea = el.querySelector('textarea')
                    if textarea:
                        # Make textarea permanently non-interactive
                        textarea.setAttribute('readonly', 'readonly')
                        textarea.setAttribute('disabled', 'disabled')
                        textarea.style.pointerEvents = 'none'
                        textarea.style.opacity = '0'
                        textarea.style.position = 'absolute'
                        textarea.style.left = '-9999px'
                        
                        # Prevent all focus events
                        def prevent_focus_handler(e):
                            textarea.blur()
                        textarea.addEventListener('focus', create_proxy(prevent_focus_handler), True)
                except Exception as e:
                    window.console.log(f"Error disabling textarea: {e}")
                """
            else:
                answer_field = None
            
            step_obj = {
                "step": step_data,
                "container": step_div,
                "answer_mf": answer_field,
                "attempts": 0,
                "attempt_history": [],
                "correct": False,
                "finalized": False,
                "step_start_time": window.Date.now()
            }
            
            # Restore state if exists
            if index in self.problem_states and step_idx < len(self.problem_states[index]):
                saved = self.problem_states[index][step_idx]
                step_obj.update(saved)
                if saved.get("correct") and saved.get("attempt_history") and answer_field:
                    for attempt in reversed(saved["attempt_history"]):
                        if attempt.get("correct"):
                            answer_field.latex(attempt.get("answer_latex", ""))
                            break
            
            self.solve_state.append(step_obj)
            
            # Add event listeners
            submit_btn = step_div.querySelector(".submitAnswer")
            finalize_btn = step_div.querySelector(".finalizeStep")
            next_btn = step_div.querySelector(".nextStep")
            
            if submit_btn:
                submit_btn.addEventListener("click", create_proxy(lambda e, i=step_idx: self.submit_answer(e, i)))
            if finalize_btn:
                finalize_btn.addEventListener("click", create_proxy(lambda e, i=step_idx: self.finalize_step(e, i)))
            if next_btn:
                next_btn.addEventListener("click", create_proxy(lambda e, i=step_idx: self.next_step(e, i)))
            
            # ⭐ ADD INPUT BUTTON LISTENERS
            input_btns = step_div.querySelectorAll(".input-btn")
            for btn_idx in range(input_btns.length):
                btn = input_btns[btn_idx]
                action = btn.getAttribute("data-action")
                
                def make_input_handler(s_idx, act, ans_field):
                    def handler(e):
                        self.handle_input_button(s_idx, act, ans_field)
                    return handler
                
                btn.addEventListener("click", create_proxy(make_input_handler(step_idx, action, answer_field)))
        
        # Show first unfinished step
        for i, step in enumerate(self.solve_state):
            if not step.get("finalized", False):
                self.show_step(i)
                break
        else:
            self.show_step(0)
        
        # ⭐ RENDER MATHJAX FOR ALL DESCRIPTIONS
        def render_mathjax():
            if hasattr(window, 'MathJax'):
                try:
                    if hasattr(window.MathJax, 'typesetPromise'):
                        window.MathJax.typesetPromise([container])
                        window.console.log("✅ MathJax typesetPromise called")
                    elif hasattr(window.MathJax, 'typeset'):
                        window.MathJax.typeset([container])
                        window.console.log("✅ MathJax typeset called")
                    elif hasattr(window.MathJax, 'Hub'):
                        window.MathJax.Hub.Queue(["Typeset", window.MathJax.Hub, container])
                        window.console.log("✅ MathJax Hub.Queue called")
                except Exception as e:
                    window.console.error(f"❌ MathJax error: {e}")
            else:
                window.console.error("❌ MathJax not available")
        
        # Delay rendering to ensure DOM is ready
        window.setTimeout(create_proxy(render_mathjax), 200)
        
        self.save_to_storage()
    
    def show_step(self, idx):
        """Show a step by index"""
        if idx >= len(self.solve_state): 
            return

        step = self.solve_state[idx]

        # ✅ Check if container exists (it's a DOM element, not serializable)
        if "container" in step and step["container"]:
            step["container"].style.display = "block"
            step["step_start_time"] = window.Date.now()
        else:
            window.console.error(f"Step {idx} has no container element")    
            
    def submit_answer(self, event, step_idx):
        """Submit answer validates that user's answer equals the EXPRESSION"""

        # ✅ DEBUG: Log which problem and step we're working on
        window.console.log(f"Submit answer: problem {self.current_problem_index}, step {step_idx}")

        # Verify we're using the correct state
        if not hasattr(self, 'solve_state') or step_idx >= len(self.solve_state):
            window.console.error(f"Invalid state: step_idx={step_idx}, solve_state length={len(self.solve_state) if hasattr(self, 'solve_state') else 0}")
            window.alert("Error: Invalid step state. Please reload the problem.")
            return

        step = self.solve_state[step_idx]
        step_data = step["step"]

    
        if step.get("finalized"):
            self.show_feedback(step_idx, "✅ This step is already finalized", "#6d28d9")
            return

        if not step.get("answer_mf"):
            self.show_feedback(step_idx, "❌ Math input not ready", "#b91c1c")
            return

        user_latex = step["answer_mf"].latex().strip()
        if not user_latex:
            self.show_feedback(step_idx, "❌ Enter an answer first", "#b91c1c")
            return

        # Parse user answer
        parsed_user = self.math_parser.parse(user_latex)
        if not parsed_user:
            self.show_feedback(step_idx, "❌ Could not parse your answer", "#b91c1c")
            return

        # Parse expression
        expression_latex = step_data.get("expression", "")
        if not expression_latex:
            self.show_feedback(step_idx, "❌ No expression to validate against", "#b91c1c")
            return

        parsed_expression = self.math_parser.parse(expression_latex)
        if not parsed_expression:
            self.show_feedback(step_idx, "❌ Could not parse expression", "#b91c1c")
            return

        # Normalize and compare
        user_normalized = self.math_parser.normalize(parsed_user)
        expression_normalized = self.math_parser.normalize(parsed_expression)
        correct = self.math_parser.compare(expression_normalized, user_normalized)

        # Record attempt
        time_taken = round((window.Date.now() - step["step_start_time"]) / 1000, 2)
        step["attempts"] += 1
        step["attempt_history"].append({
            "attempt_number": step["attempts"],
            "answer_latex": user_latex,
            "correct": correct,
            "time_taken_seconds": time_taken
        })

        # Update UI
        if correct:
            self.show_feedback(step_idx, 
                "✅ Correct! Your answer equals the expression.<br>"
                "Click <strong>Finalize</strong> to verify your solution method.", 
                "#059669")
            step["correct"] = True
            finalize_btn = step["container"].querySelector(".finalizeStep")
            if finalize_btn:
                finalize_btn.disabled = False
        else:
            self.show_feedback(step_idx, "❌ Incorrect. Try again!", "#b91c1c")

        self.add_attempt_to_history(step_idx, user_latex, correct, time_taken)

        # ❌ REMOVED: Don't update header here, only on finalize
        # self.update_step_progress_display(self.current_problem_index)

        self.save_to_storage()
        
    def finalize_step(self, event, step_idx):
        """Finalize validates structure - keeps button active if structure wrong"""

        # ✅ DEBUG: Log which problem and step we're working on
        window.console.log(f"Finalize step: problem {self.current_problem_index}, step {step_idx}")

        # Verify we're using the correct state
        if not hasattr(self, 'solve_state') or step_idx >= len(self.solve_state):
            window.console.error(f"Invalid state: step_idx={step_idx}, solve_state length={len(self.solve_state) if hasattr(self, 'solve_state') else 0}")
            window.alert("Error: Invalid step state. Please reload the problem.")
            return

        step = self.solve_state[step_idx]
    
        if not step.get("correct"):
            self.show_feedback(step_idx, "❌ Submit correct answer first", "#b91c1c")
            return

        user_latex = step["answer_mf"].latex().strip() if step.get("answer_mf") else ""
        if not user_latex:
            self.show_feedback(step_idx, "❌ No answer to finalize", "#b91c1c")
            return

        # Parse user answer
        parsed_user = None
        try:
            parsed_user = self.math_parser.parse(user_latex)
        except Exception as e:
            window.console.log(f"Parse user error: {e}")

        if parsed_user is None:
            self.show_feedback(step_idx,
                "⚠️ Could not parse your answer. Finalized (no structure check).",
                "#92400e")
            step["finalized"] = True
            self._finalize_step_ui(step_idx)
            # ✅ Update on success
            self.update_step_progress_display(self.current_problem_index)
            self.save_to_storage()
            return

        # Get expected structure
        expected_struct = step["step"].get("expected_structure")
        if not expected_struct:
            self.show_feedback(step_idx,
                "❌ ERROR: Missing expected_structure in problem data.",
                "#dc2626")
            step["finalized"] = True
            self._finalize_step_ui(step_idx)
            # ✅ Update on success
            self.update_step_progress_display(self.current_problem_index)
            self.save_to_storage()
            return

        # Extract user structure
        try:
            user_struct = self.math_parser.extract_structure(parsed_user)
        except Exception as e:
            window.console.log(f"Structure extraction error: {e}")
            self.show_feedback(step_idx,
                "⚠️ Error analyzing structure. Finalized (no structure check).",
                "#92400e")
            step["finalized"] = True
            self._finalize_step_ui(step_idx)
            # ✅ Update on success
            self.update_step_progress_display(self.current_problem_index)
            self.save_to_storage()
            return

        # Compare structures
        same_operators = user_struct["operators"] == expected_struct["operators"]
        same_operands = user_struct["operands"] == expected_struct["operands"]
        same_structure = same_operators and same_operands

        # Track finalize attempts
        if not step.get("finalize_attempts"):
            step["finalize_attempts"] = 0
        if not step.get("finalize_history"):
            step["finalize_history"] = []

        step["finalize_attempts"] += 1

        if same_structure:
            # ✅ SUCCESS - finalize and proceed
            step["finalized"] = True
            step["structure_correct"] = True

            step["finalize_history"].append({
                "attempt_number": step["finalize_attempts"],
                "structure_match": True,
                "user_structure": user_struct,
                "timestamp": window.Date.now()
            })

            # Disable buttons
            finalize_btn = step["container"].querySelector(".finalizeStep")
            if finalize_btn: 
                finalize_btn.disabled = True

            submit_btn = step["container"].querySelector(".submitAnswer")
            if submit_btn: 
                submit_btn.disabled = True

            # Show next step button
            if step_idx + 1 < len(self.solve_state):
                next_btn = step["container"].querySelector(".nextStep")
                if next_btn:
                    next_btn.style.display = "block"

            msg = "✅ Finalized — your solution method matches perfectly!"
            color = "#059669"

            # ✅ UPDATE HEADER ON SUCCESS ONLY
            self.update_step_progress_display(self.current_problem_index)

        else:
            # ❌ FAILED - keep trying
            step["finalized"] = False
            step["structure_correct"] = False

            step["finalize_history"].append({
                "attempt_number": step["finalize_attempts"],
                "structure_match": False,
                "user_structure": user_struct,
                "expected_structure": expected_struct,
                "timestamp": window.Date.now()
            })

            # Build feedback message
            if same_operators and not same_operands:
                msg = (
                    f"❌ Attempt {step['finalize_attempts']}: Structure mismatch.<br>"
                    "Correct operations, different values.<br>"
                    f"<small>Expected: {expected_struct['operands']}</small><br>"
                    f"<small>You used: {user_struct['operands']}</small>"
                )
            elif not same_operators and same_operands:
                msg = (
                    f"❌ Attempt {step['finalize_attempts']}: Structure mismatch.<br>"
                    "Same values, different method.<br>"
                    f"<small>Expected ops: {expected_struct['operators']}</small><br>"
                    f"<small>Your ops: {user_struct['operators']}</small>"
                )
            else:
                msg = (
                    f"❌ Attempt {step['finalize_attempts']}: Structure mismatch.<br>"
                    f"<small>Expected: ops={expected_struct['operators']}, vals={expected_struct['operands']}</small><br>"
                    f"<small>Yours: ops={user_struct['operators']}, vals={user_struct['operands']}</small>"
                )
            msg += "<br><strong>Try a different approach and click Finalize again.</strong>"
            color = "#dc2626"

            # Add to history display
            self.add_finalize_attempt_to_history(step_idx, user_struct, expected_struct, False)

            # ❌ DO NOT UPDATE HEADER ON FAILURE

        self.show_feedback(step_idx, msg, color)
        self.save_to_storage()

    def update_step_progress_display(self, prob_idx):
        """Update accordion header with current progress (only finalized steps count)"""
        acc = document.querySelector(f".accordion-problem[data-index='{prob_idx}']")
        if not acc: 
            return

        header = acc.querySelector(".progress-summary")
        if not header:
            return

        # Get current state
        if self.current_problem_index == prob_idx and hasattr(self, 'solve_state'):
            prob_state = self.solve_state
        else:
            prob_state = self.problem_states.get(prob_idx, [])

        if not prob_state:
            return

        # Calculate stats - only count finalized steps
        total_steps = len(prob_state)
        finalized = sum(1 for s in prob_state if s.get("finalized", False))

        # ✅ Build display with conditional styling
        if finalized == total_steps and total_steps > 0:
            # ✅ ALL steps finalized - GREENISH background
            status = f"✅ {finalized}/{total_steps} completed"
            text_color = "#059669"  # Green text
            bg_color = "#d1fae5"    # ✅ Greenish background (emerald-100)
            acc.classList.add("finished")
        elif finalized > 0:
            # ⚠️ Some steps finalized - KEEP ORIGINAL blue background
            status = f"✅ {finalized}/{total_steps} completed"
            text_color = "#059669"  # Green text (to show progress)
            bg_color = "#f0f4ff"    # ❌ Keep original light blue
            acc.classList.remove("finished")
        else:
            # No steps finalized yet - ORIGINAL blue background
            status = f"{finalized}/{total_steps} completed"
            text_color = "#6b7280"  # Gray text
            bg_color = "#f0f4ff"    # Original light blue
            acc.classList.remove("finished")

        # Update header text and colors
        header.innerHTML = status
        header.style.color = text_color

        # ✅ Update header background color
        header_el = acc.querySelector(".accordion-header")
        if header_el:
            header_el.style.background = bg_color        
        
    def add_finalize_attempt_to_history(self, step_idx, user_struct, expected_struct, success):
        """Add finalize attempt to history display"""
        step = self.solve_state[step_idx]
        history = step["container"].querySelector(".attempts-history")
        if history:
            history.style.display = "block"

            entry = document.createElement("div")
            entry.style.cssText = "margin-bottom:10px;padding:10px;border-radius:8px;"

            if success:
                entry.style.background = "#dcfce7"
                entry.style.border = "2px solid #86efac"
                status_text = "✅ Structure Match"
                status_emoji = "🎯"
            else:
                entry.style.background = "#fef3c7"  # Yellow/amber background for finalize failures
                entry.style.border = "2px solid #fbbf24"  # Amber border
                status_text = "⚠️ Structure Mismatch"
                status_emoji = "🔍"

            # ✅ Label as "Finalize Attempt"
            entry.innerHTML = f"""
            <div style='font-weight:700;font-size:15px;'>
                {status_emoji} Finalize Attempt #{step.get('finalize_attempts', 0)} - {status_text}
            </div>
            <div style='margin-top:6px;padding:8px;background:#fff;border-radius:6px;font-size:13px;'>
                <strong>Your structure:</strong><br>
                Operations: {user_struct.get('operators', {})}<br>
                Values: {user_struct.get('operands', {})}
            </div>
            """

            if not success:
                expected_info = document.createElement("div")
                expected_info.style.cssText = "margin-top:6px;padding:8px;background:#fff;border-radius:6px;font-size:13px;"
                expected_info.innerHTML = f"""
                <strong>Expected structure:</strong><br>
                Operations: {expected_struct.get('operators', {})}<br>
                Values: {expected_struct.get('operands', {})}
                """
                entry.appendChild(expected_info)

            history.appendChild(entry)
        
    def next_step(self, event, step_idx):
        self.solve_state[step_idx]["container"].style.display = "none"
        if step_idx + 1 < len(self.solve_state):
            self.show_step(step_idx + 1)
        self.save_to_storage()
    
    def show_feedback(self, step_idx, message, color):
        step = self.solve_state[step_idx]
        feedback = step["container"].querySelector(".step-feedback")
        if feedback:
            feedback.innerHTML = f"<div style='color:{color};background:{color}20;padding:10px;border-radius:6px;'>{message}</div>"
    
    def add_attempt_to_history(self, step_idx, latex, correct, time_taken):
        """Add submit answer attempt to history display"""
        step = self.solve_state[step_idx]
        history = step["container"].querySelector(".attempts-history")
        if history:
            history.style.display = "block"

            entry = document.createElement("div")
            entry.style.cssText = "margin-bottom:10px;padding:10px;border-radius:8px;"
            entry.style.background = "#dcfce7" if correct else "#fee2e2"
            entry.style.border = f"2px solid {'#86efac' if correct else '#fecaca'}"

            # ✅ Label as "Submit Attempt"
            entry.innerHTML = f"""
            <div style='font-weight:700;font-size:15px;'>
                📝 Submit Attempt #{step['attempts']} ({time_taken}s) - {'✅ Correct' if correct else '❌ Incorrect'}
            </div>
            <div style='margin-top:6px;padding:8px;background:#fff;border-radius:6px;'>
                \({latex}\)
            </div>
            """

            history.appendChild(entry)

            # Re-render MathJax
            if hasattr(window, 'MathJax'):
                window.MathJax.typesetPromise([entry])    
                
    def update_progress(self, prob_idx):
        acc = document.querySelector(f".accordion-problem[data-index='{prob_idx}']")
        if not acc: return
        
        prob_state = self.problem_states.get(prob_idx, [])
        total = len(self.problem_set[prob_idx].get("steps", []))
        finalized = sum(1 for s in prob_state if s.get("finalized", False))
        
        header = acc.querySelector(".progress-summary")
        if finalized == total and total > 0:
            header.innerHTML = f"✅ {finalized}/{total} completed"
            header.style.color = "#059669"
            acc.classList.add("finished")
        else:
            header.innerHTML = f"{finalized}/{total} completed"
            header.style.color = "#6b7280"
    
    def reset_current(self, event):
        if self.current_problem_index is None:
            window.alert("No problem selected")
            return
        
        if not window.confirm("Reset current problem progress?"):
            return
        
        # Reset state
        for step in self.solve_state:
            step["attempts"] = 0
            step["attempt_history"] = []
            step["correct"] = False
            step["finalized"] = False
            if step.get("answer_mf"):
                step["answer_mf"].latex("")
            
            history = step["container"].querySelector(".attempts-history")
            if history:
                history.innerHTML = ""
                history.style.display = "none"
            
            submit_btn = step["container"].querySelector(".submitAnswer")
            if submit_btn:
                submit_btn.disabled = False
            finalize_btn = step["container"].querySelector(".finalizeStep")
            if finalize_btn:
                finalize_btn.disabled = True
            next_btn = step["container"].querySelector(".nextStep")
            if next_btn:
                next_btn.style.display = "none"
            feedback = step["container"].querySelector(".step-feedback")
            if feedback:
                feedback.innerHTML = ""
        
        # Save and refresh
        self.problem_states[self.current_problem_index] = self.solve_state
        self.save_to_storage()
        self.show_step(0)
        self.update_progress(self.current_problem_index)
        
        window.alert("Problem reset successfully")
    
    def export_progress(self, event):
        """Export student progress with proper JsProxy conversion"""
        if not self.problem_set:
            window.alert("No problems to export")
            return

        try:
            window.console.log("=== Starting progress export ===")

            # ✅ Save current problem state first
            if self.current_problem_index is not None and hasattr(self, 'solve_state'):
                window.console.log(f"Saving current problem {self.current_problem_index} state")
                serializable_state = []
                for step in self.solve_state:
                    step_data = {
                        "step": step.get("step", {}),
                        "attempts": step.get("attempts", 0),
                        "attempt_history": step.get("attempt_history", []),
                        "correct": step.get("correct", False),
                        "finalize_attempts": step.get("finalize_attempts", 0),
                        "finalize_history": step.get("finalize_history", []),
                        "structure_correct": step.get("structure_correct", False),
                        "finalized": step.get("finalized", False),
                        "step_start_time": step.get("step_start_time", window.Date.now())
                    }
                    serializable_state.append(step_data)

                self.problem_states[self.current_problem_index] = serializable_state

            # ✅ Build export data with conversion
            window.console.log("Building export data...")
            raw_export_data = {
                "problem_set_id": self.current_problem_set_uuid,
                "problem_set": self.problem_set,
                "problem_states": self.problem_states,
                "export_date": window.Date.new().toISOString()
            }

            # ✅ Convert all JsProxy objects to native Python types
            window.console.log("Converting to native types...")
            export_data = self._convert_to_native(raw_export_data)

            # ✅ Serialize to JSON
            window.console.log("Serializing to JSON...")
            json_str = json.dumps(export_data)
            window.console.log(f"JSON length: {len(json_str)}")

            # ✅ Compress
            window.console.log("Compressing...")
            import brotli
            compressed = brotli.compress(json_str.encode('utf-8'))
            window.console.log(f"Compressed length: {len(compressed)}")

            # ✅ Encode to base64
            b64_str = base64.b64encode(compressed).decode('utf-8')
            window.console.log(f"Base64 length: {len(b64_str)}")

            # ✅ Create export file content
            output = f"=== STUDENT PROGRESS EXPORT ===\n{b64_str}\n=== END EXPORT ==="

            # ✅ Download as file
            blob = window.Blob.new([output], {"type": "text/plain"})
            url = window.URL.createObjectURL(blob)
            a = document.createElement("a")
            a.href = url
            a.download = f"progress_{window.Date.new().toISOString().split('T')[0]}.txt"
            document.body.appendChild(a)
            a.click()
            a.remove()

            # Cleanup
            window.setTimeout(create_proxy(lambda: window.URL.revokeObjectURL(url)), 1000)

            window.console.log("✅ Progress export successful!")
            window.alert("✅ Progress exported successfully!")

        except Exception as e:
            window.console.error(f"❌ Export progress failed: {e}")
            import traceback
            window.console.error(traceback.format_exc())
            window.alert(f"❌ Export failed: {e}")

    def export_telegram(self, event):
        # Simplified telegram export
        window.alert("Telegram export feature coming soon")
    
    def clear_all(self, event):
        if not window.confirm("Clear ALL data? This cannot be undone."):
            return
        
        window.localStorage.clear()
        self.problem_set = []
        self.problem_states = {}
        self.current_problem_index = None
        self.current_problem_set_uuid = None
        
        # Reset UI
        container = document.querySelector("#solveProblemsContainer")
        if container:
            container.innerHTML = ""
        initial_panel = document.querySelector("#initialLoadPanel")
        if initial_panel:
            initial_panel.style.display = "block"
        self.update_problem_set_info("")
        
        window.alert("All data cleared")
    
    def _convert_to_native(self, obj):
        """Recursively convert all JsProxy objects to native Python types"""
        from pyodide.ffi import JsProxy

        # Handle None
        if obj is None:
            return None

        # Already native Python basic types - return as-is
        if isinstance(obj, (str, int, float, bool)):
            return obj

        # Handle JsProxy (JavaScript objects)
        if isinstance(obj, JsProxy):
            try:
                # First attempt: Use JavaScript's JSON.stringify
                js_json_str = window.JSON.stringify(obj)
                # Convert JS string to Python string and parse
                python_str = str(js_json_str)
                return json.loads(python_str)
            except Exception as e1:
                window.console.log(f"JSON.stringify failed: {e1}, trying to_py()")
                try:
                    # Second attempt: Use to_py()
                    converted = obj.to_py()
                    # Recursively convert the result
                    return self._convert_to_native(converted)
                except Exception as e2:
                    window.console.log(f"to_py() failed: {e2}, using str()")
                    # Last resort: convert to string
                    return str(obj)

        # Handle Python dict - recursively convert all values
        if isinstance(obj, dict):
            result = {}
            for key, value in obj.items():
                # Ensure key is string
                str_key = str(key)
                # Recursively convert value
                result[str_key] = self._convert_to_native(value)
            return result

        # Handle Python list - recursively convert all items
        if isinstance(obj, (list, tuple)):
            return [self._convert_to_native(item) for item in obj]

        # Unknown type - log warning and convert to string
        window.console.log(f"Warning: Unknown type {type(obj)}, converting to string")
        try:
            return str(obj)
        except:
            return None
      
    def save_to_storage(self):
        """Save current state to localStorage with thorough JsProxy conversion"""
        try:
            window.console.log("=== Starting save ===")

            # ✅ Step 1: Convert current solve_state to serializable format
            if self.current_problem_index is not None and hasattr(self, 'solve_state'):
                window.console.log(f"Converting solve_state for problem {self.current_problem_index}")

                serializable_state = []
                for i, step in enumerate(self.solve_state):
                    window.console.log(f"Processing step {i}")

                    # Extract and convert each field individually
                    step_data = {
                        "step": self._convert_to_native(step.get("step", {})),
                        "attempts": int(step.get("attempts", 0)),
                        "attempt_history": self._convert_to_native(step.get("attempt_history", [])),
                        "correct": bool(step.get("correct", False)),
                        "finalize_attempts": int(step.get("finalize_attempts", 0)),
                        "finalize_history": self._convert_to_native(step.get("finalize_history", [])),
                        "structure_correct": bool(step.get("structure_correct", False)),
                        "finalized": bool(step.get("finalized", False)),
                        "step_start_time": float(step.get("step_start_time", 0))
                    }

                    # Double-check conversion
                    step_data = self._convert_to_native(step_data)
                    serializable_state.append(step_data)

                # Store the converted state
                self.problem_states[self.current_problem_index] = serializable_state
                window.console.log("✅ solve_state converted successfully")

            # ✅ Step 2: Convert entire problem_states dict
            window.console.log("Converting problem_states...")
            converted_problem_states = {}
            for key, value in self.problem_states.items():
                # Ensure key is integer
                int_key = int(key) if key is not None else 0
                # Convert value (which is a list of step states)
                converted_problem_states[int_key] = self._convert_to_native(value)

            window.console.log("✅ problem_states converted successfully")

            # ✅ Step 3: Build final data structure with all conversions
            window.console.log("Building final data structure...")
            data = {
                "problem_set_id": str(self.current_problem_set_uuid) if self.current_problem_set_uuid else None,
                "problem_set": self._convert_to_native(self.problem_set),
                "problem_states": converted_problem_states,
                "current_problem_index": int(self.current_problem_index) if self.current_problem_index is not None else None
            }

            # ✅ Step 4: Final conversion pass on entire data structure
            window.console.log("Final conversion pass...")
            data = self._convert_to_native(data)

            window.console.log("✅ All data converted to native types")

            # ✅ Step 5: Serialize to JSON
            window.console.log("Serializing to JSON...")
            json_str = json.dumps(data)
            window.console.log(f"✅ JSON created, length: {len(json_str)}")

            # ✅ Step 6: Compress
            window.console.log("Compressing...")
            import brotli
            compressed = brotli.compress(json_str.encode('utf-8'))
            window.console.log(f"✅ Compressed, length: {len(compressed)}")

            # ✅ Step 7: Encode to base64
            window.console.log("Encoding to base64...")
            b64_str = base64.b64encode(compressed).decode('utf-8')
            window.console.log(f"✅ Base64 encoded, length: {len(b64_str)}")

            # ✅ Step 8: Save to localStorage
            window.console.log("Saving to localStorage...")
            window.localStorage.setItem("problem_solver_data", b64_str)

            window.console.log("✅✅✅ Save completed successfully!")
            self.show_indicator("💾 Saved", "#10b981")

        except Exception as e:
            window.console.error(f"❌ Save failed: {e}")
            import traceback
            tb = traceback.format_exc()
            window.console.error(tb)

            # Try to identify which part failed
            try:
                # Test serialization of problem_set alone
                test_ps = self._convert_to_native(self.problem_set)
                json.dumps(test_ps)
                window.console.log("✅ problem_set is serializable")
            except Exception as e2:
                window.console.error(f"❌ problem_set failed: {e2}")

            try:
                # Test serialization of problem_states alone
                test_states = self._convert_to_native(self.problem_states)
                json.dumps(test_states)
                window.console.log("✅ problem_states is serializable")
            except Exception as e3:
                window.console.error(f"❌ problem_states failed: {e3}")

            self.show_indicator("❌ Save Failed", "#dc2626")
        
    def load_from_storage(self):
        try:
            stored = window.localStorage.getItem("problem_solver_data")
            if not stored: return
            
            import brotli, base64
            compressed = base64.b64decode(stored)
            json_str = brotli.decompress(compressed).decode('utf-8')
            data = json.loads(json_str)
            
            self.current_problem_set_uuid = data.get("problem_set_id")
            self.problem_set = data.get("problem_set", [])
            self.problem_states = {int(k): v for k, v in data.get("problem_states", {}).items()}
            self.current_problem_index = data.get("current_problem_index")
            
            if self.problem_set:
                self.update_problem_set_info(data.get("description", ""))
                self.render_problems()
        except:
            pass
    
    def show_indicator(self, text, color):
        indicator = document.querySelector("#storageIndicator")
        if indicator:
            indicator.textContent = text
            indicator.style.background = color
            indicator.classList.add("show")
            window.setTimeout(create_proxy(lambda: indicator.classList.remove("show")), 2000)
app = ProblemSolverApp()

# Import required libraries
import sympy as sp
import brotli

# Start the application
window.setTimeout(create_proxy(app.init), 700)
  </script>
</body>
</html>
